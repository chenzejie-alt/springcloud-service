服务降级---》
hystrix断路器：
一、hystrix概述：
1.分布式系统面临的问题：
复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。
服务雪崩：
多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”。
如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，
所谓的“雪崩效应”。
对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还
可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延
迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。
所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，
这样就会发生级联故障，或者叫做雪崩。
2.hystrix是什么？
hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免地会调用失败，比如：超时，异常等，
hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。
“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合
预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会
被长时间、不必要地占用，从而避免了故障在分布式系统的蔓延，乃至雪崩。
3.hystrix能干什么？
服务降级
服务熔断
接近实时的监控
服务限流，隔离等...

二、hystrix重要概念：
1.服务降级：fallback 对方系统不可用了，你需要给我一个兜底的解决方法
服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback
哪些情况会触发服务降级？
（1）程序出现异常
（2）超时
（3）服务熔断触发服务降级
（4）线程池/信号量打满也会导致服务降级
2.服务熔断：break
类似保险丝达到最大服务访问后，直接拒绝访问，拉闸限电（熔断），然后调用服务降级的方法并返回友好提示
就是保险丝：服务的降级-》服务熔断-》恢复调用链路
3.服务限流：flowlimit
秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。
三、hystrix案例：
1.构建：
新建springcloud_provider_hystrix_payment_8001
改pom
写yaml
主启动
业务类：service，controller
正常测试：启动eureka7001，启动springcloud_provider_hystrix_payment_8001，
访问success的方法：http://localhost:8001/payment/hystrix/ok/1
每次调用耗费五秒钟：http://localhost:8001/payment/hystrix/timeout/1
上述module均ok，以上述为根基平台，从正确--->错误--->降级熔断--->恢复
2.高并发测试：
上述在非高并发的情形下，还能勉强满足，但是
jmeter压测测试：开启jmeter，来20000个并发来压死8001，20000个请求都去访问paymentInfo_TimeOut服务；
                再来一个访问：http://localhost:8001/payment/hystrix/ok/1
                两个都在自己转圈圈，为什么会被卡死？tomcat的默认工作线程数被打满了，没有多余的线程来分解压力和处理。
jmeter压测结论：上面还是服务提供者8001自己测试，假如此时外部的消费者8080也来访问，那消费者只能干等，最终导致消费端8080
                不满意，服务端8001直接被拖死。
看热闹不嫌事大，8080新建加入：springcloud_consumer_feign_hystrix_order_8080
新建
改pom
写yaml
主启动
业务类
正常测试
高并发测试：20000个线程压8001，消费端8080微服务再去访问正常的ok微服务8001地址
http://localhost/consumer/payment/hystrix/ok/1
消费端8080，要么转圈圈等待，要么消费端报超时错误。
3.故障现象和导致原因：
8001同一层次的其他接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。
8080此时调用8001，客户端访问响应缓慢，转圈圈。
4.上述结论：
正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生。
5.如何解决？解决的要求
超时导致服务器变慢，转圈：超时不再等待
出错（宕机或程序运行出错）：出错要有兜底
解决：
对方服务8001超时了，调用者8080不能一直卡死等待，必须有服务降级
对方服务8001宕机了，调用者8080不能一直卡死等待，必须有服务降级
对方服务8001OK，调用者8080自己出故障或有自我要求（自己的等待小于服务提供者），自己处理降级
（1）服务降级：
降级配置：@HystrixCommand
8001先从自身找问题：设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，做服务降级fallback
8001fallback：
业务类启动：@HystrixCommand报异常后如何处理：
一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法。
错误信息有两种：第一种：程序超时；第二种：程序出错，抛出异常
结论：当服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler
主启动类激活：添加新注解@EnableCircuitBreaker
8080fallback
8080订单微服务，也可以更好的保护自己，自己也可以依样画葫芦进行客户端降级保护
yaml：开启feign hystrix enabled：true
主启动
业务类
目前问题：
每个业务方法对应一个兜底的方法，代码膨胀。
统一和自定义的分开。
解决问题：
每个方法配置一个兜底的方法，代码膨胀:
feign接口系列。@DefaultProperties(defaultFallback = "")
每个方法配置一个服务降级方法，技术上可以，实际上代码膨胀。除了个别重要的核心业务专属，其他普通的可以通过
@DefaultProperties(defaultFallback = "") 统一跳转到统一结果处理页面。
通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量。
兜底的方法和业务方法混在一起，混乱:
服务降级，客户端去调用服务端，碰上服务端宕机或关闭
本次案例服务降级处理是在客户端8080实现完成的，与8001服务端没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理
的实现类即可实现解耦
未来我们要面对的异常：运行时异常，超时异常，宕机
再看我们的业务类：PaymentController：业务方法和fallback方法混合在一起，每个业务方法都要提供一个。代码膨胀，耦合度高
修改springcloud_consumer_feign_hystrix_order_8080
根据springcloud_consumer_feign_hystrix_order_8080已经有的PaymentHystrixService接口，重新新建一个类
PaymentFallbackService实现该接口，统一为接口里面的方法进行异常处理。
PaymentFallbackService类实现PaymentFeignClientService接口。
yaml:
# 开启服务降级
feign:
  hystrix:
    enabled: true
PaymentFeignClientService接口
测试：
单个eureka先启动7001
PaymentHystrixMain8001启动
正常访问测试
故意关闭微服务8001
客户端自己调用提示：此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息
而不会挂起耗死服务器。

（2）服务熔断：
断路器：一句话就是家里的保险丝
熔断是什么？熔断机制概述
熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，
进而熔断该节点微服务的调用，快速返回错误的响应信息。
当监测到该节点的微服务调用响应正常后，恢复调用链路。
在springcloud框架里，熔断机制通过hystrix实现。hystrix会监控微服务调用间调用的状况。
当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，熔断机制的注解是@HystrixCommand。
大神论文：http://martinfowler.com/bliki/CircuitBreaker.html
实操：多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址
原理，总结：
熔断类型：
熔断打开，请求不再进行调用当前服务，内部配置时钟一般为MTTR（平均故障处理时间），当打开时长达到所设时钟则进入半熔断状态
熔断关闭，熔断关闭不会对服务进行熔断
熔断半开，部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。

断路器在什么情况下开始起作用？
涉及到断路器的三个重要参数：快照时间窗，请求总数阈值，错误百分比阈值。
1.快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
2.请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断，默认为20，意味着在10秒内，如果该hystrix命令的调用次数
不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。
3.错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是
超过了50%的错误百分比，在默认设定的50%阈值情况下，这时候就会将断路器打开。
断路器开启或关闭的条件？
当满足一定的阈值的时候（默认10秒内超过了20个请求次数）
当失败率达到一定的时候（默认10秒内超过50%的请求失败）
到达以上阈值，断路器将会开启
当开启的时候，所有的请求都不会进行转发
一段时间之后（默认是5秒），这个时候断路器是半开状态，会让一个请求进行转发，如果成功，断路器会关闭，若失败，继续开启，重复4和5。
断路器打开之后：
再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback，通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少
响应延迟的效果。
原来的主逻辑如何恢复呢？
对于这一问题，hystrix也为我们实现自动恢复功能。
当断路器打开，对主逻辑进行熔断后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，
当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，
主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。
（3）服务限流：
四、hystrix工作流程：
https://github.com/Netflix/Hystrix/wiki/How-it-Works

五、服务监控hystrixDashboard
1.概述：
除了隔离依赖服务的调用外，Hystrix还提供了准实时的调用监控，（Hystrix Dashboard），Hystrix会持续地记录所有通过
Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等，
Netflix通过Hystrix-metrics-event-stream项目实现了对以上的监控，springcloud也提供了hystrix dashboard的整合，
对监控内容转化成可视化界面。
2.仪表盘9001：
新建springcloud_consumer_hystrix_dashboard_9001
改pom
写yaml
hystrixDashboardMain9001+新注解@EnableHystrixDashboard
所有Provider微服务提供类（8001/8002/8003）都需要提供监控依赖配置
启动springcloud_consumer_hystrix_dashboard_9001该微服务后续监控微服务8001：http://localhost:9001/hystrix
3.断路器演示：（服务监控hystrixDashboard）
修改springcloud_provider_hystrix_payment_8001：注意新版本Hystrix需要在主启动类PaymentHystrixMain8001指定监控路径
监控测试：
启动1个eureka或者3个eureka集群均可。
启动springcloud_provider_hystrix_payment_8001
在dashboard界面输入：http://localhost:8001/hystrix.stream     2000    T3
实心圈：
共有两种含义，它通过颜色的变化代表了实例的健康程度，它的健康色从绿色---》黄色---》橙色---》红色递减。
该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量变化，流量越大该实心圆越大，所以通过实心圆的展示，就可以在
大量的实例中快速的发现故障实例和高压力实例。